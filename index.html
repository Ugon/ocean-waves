<html>
<head>
    <title>Ocean Waves</title>
    <meta http-equiv="content-type" content="text/html">
</head>
<body>
    <canvas id="canvas"></canvas>
</body>

<script type="text/javascript" src="parameters.js"></script>
<script type="text/javascript" src="webgl-boilerplate.js"></script>

<script id="pass-position-vertex-shader" type="x-shader/x-vertex">
    precision highp float;
    
    attribute vec2 a_position;

    varying vec2 v_position;
    
    void main(void) {
        v_position = a_position;
        gl_Position = vec4(a_position, 0, 1);
    }
</script>

<script id="height-init-in-frequency-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 v_position; //[-1, 1]

    uniform sampler2D u_randomComplexNumbers;
    uniform vec2 u_windVector;
    uniform float u_transformSize; //(WIDTH, HEIGHT)
    uniform float u_areaSize;      //size of rendered area (eg. 100km x 100km)

    float PI = 3.14159265359;
    float e =  2.71828182846;
    float g =  9.81;

    float square(float a){
        return a * a;
    }

    void main(void) {
        float n2 = v_position.x * u_transformSize; //2 * n
        float m2 = v_position.y * u_transformSize; //2 * m

        float kx = PI * n2 / u_areaSize;
        float ky = PI * m2 / u_areaSize;
        vec2 k = vec2(kx, ky);
        float klen = length(k);

        float V = length(u_windVector);
        float L = V * V / g;

        // float Ph = pow(e, (-1.0 / square(klen * L))) * square(dot(normalize(k), normalize(u_windVector))) / square(klen * klen);
        float Ph = pow(e, (-1.0 / square(klen * L))) * square(dot(normalize(k), normalize(u_windVector))) / square(klen * klen) * pow(e, -square(klen * u_areaSize / 1000.0));
        float sqrtPh = sqrt(Ph * 0.5);

        vec2 randomComplexNumber = texture2D(u_randomComplexNumbers, v_position).xy;
        vec2 h0 = randomComplexNumber * sqrtPh;

        gl_FragColor = vec4(h0, 0, 1);
    }
</script>

<script id="height-after-t-in-frequency-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 v_position; //[-1, 1]

    uniform sampler2D u_h0;
    uniform float u_transformSize; //(WIDTH, HEIGHT)
    uniform float u_areaSize;      //size of rendered area (eg. 100km x 100km)
    uniform float u_t;

    float PI = 3.14159265359;
    float e =  2.71828182846;
    float g =  9.81;

    float square(float a){
        return a * a;
    }

    float omega(float klen){
        return sqrt(g * klen);
    }

    vec2 complexTryg(float alpha){
        return vec2(cos(alpha), sin(alpha));
    }

    vec2 complexMult(vec2 a, vec2 b){
        return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y + b.x);
    }

    vec2 complexConj(vec2 a){
        return vec2(a.x, -a.y);
    }

    vec2 position2TexturePosition(vec2 pos){
        return pos * 0.5 + vec2(0.5, 0.5);
    }

    void main(void) {
        float n2 = v_position.x * u_transformSize; //2 * n
        float m2 = v_position.y * u_transformSize; //2 * m

        float kx = PI * n2 / u_areaSize;
        float ky = PI * m2 / u_areaSize;
        vec2 k = vec2(kx, ky);
        float klen = length(k);

        vec2 h0k = texture2D(u_h0, position2TexturePosition(v_position)).xy;
        vec2 h0minusk = texture2D(u_h0, position2TexturePosition(-v_position)).xy;

        vec2 hkt = complexMult(h0k, complexTryg(omega(klen) * u_t)) + complexMult(complexConj(h0minusk), complexTryg(-omega(klen) * u_t));

        gl_FragColor = vec4(hkt, 0, 1);
    }
</script>

<script id="ifft-rows-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 v_position; //[-1, 1]

    uniform sampler2D u_input;
    uniform float u_transformSize; //(WIDTH, HEIGHT)
    uniform float u_subtransformSize; //(WIDTH, HEIGHT)

    float PI = 3.14159265359;

    vec2 complexTryg(float alpha){
        return vec2(cos(alpha), sin(alpha));
    }

    vec2 complexMult(vec2 a, vec2 b){
        return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y + b.x);
    }

    float position2Index(float pos){
        return u_transformSize * (pos * 0.5 + 0.5);
    }

    float index2TexturePosition(float ind){
        return ind / u_transformSize;
    }

    float position2TexturePosition(float pos){
        return pos * 0.5 + 0.5;
    }

    void main(void) {
        float index_x = position2Index(v_position.x); //[0, u_transformSize]
        float base = floor(index_x / u_subtransformSize) * u_subtransformSize * 2.0;
        float offset = mod(index_x, u_subtransformSize * 0.5);
        float x0 = base + offset;
        float x1 = x0 + u_transformSize * 0.5;
        vec2 val0 = texture2D(u_input, vec2(index2TexturePosition(x0), position2TexturePosition(v_position.y))).xy;
        vec2 val1 = texture2D(u_input, vec2(index2TexturePosition(x1), position2TexturePosition(v_position.y))).xy;
        vec2 twiddle = complexTryg((-2.0) * PI * (index_x / u_subtransformSize));
        vec2 result = vec2(val0.x + twiddle.x * val1.x - twiddle.y * val1.y, 
                           val0.y + twiddle.y * val1.x + twiddle.x * val1.y);
        gl_FragColor = vec4(result, 0, 1);
    }
</script>

<script id="ifft-cols-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 v_position; //[-1, 1]

    uniform sampler2D u_input;
    uniform float u_transformSize; //(WIDTH, HEIGHT)
    uniform float u_subtransformSize; //(WIDTH, HEIGHT)

    float PI = 3.14159265359;

    vec2 complexTryg(float alpha){
        return vec2(cos(alpha), sin(alpha));
    }

    vec2 complexMult(vec2 a, vec2 b){
        return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y + b.x);
    }

    float position2Index(float pos){
        return u_transformSize * (pos * 0.5 + 0.5);
    }

    float index2TexturePosition(float ind){
        return ind / u_transformSize;
    }

    float position2TexturePosition(float pos){
        return pos * 0.5 + 0.5;
    }

    void main(void) {
        float index_y = position2Index(v_position.y); //[0, u_transformSize]
        float base = floor(index_y / u_subtransformSize) * u_subtransformSize * 2.0;
        float offset = mod(index_y, u_subtransformSize * 0.5);
        float y0 = base + offset;
        float y1 = y0 + u_transformSize * 0.5;
        vec2 val0 = texture2D(u_input, vec2(position2TexturePosition(v_position.x), index2TexturePosition(y0))).xy;
        vec2 val1 = texture2D(u_input, vec2(position2TexturePosition(v_position.x), index2TexturePosition(y1))).xy;
        vec2 twiddle = complexTryg((-2.0) * PI * (index_y / u_subtransformSize));
        vec2 result = vec2(val0.x + twiddle.x * val1.x - twiddle.y * val1.y, 
                           val0.y + twiddle.y * val1.x + twiddle.x * val1.y);
        gl_FragColor = vec4(result, 0, 1);
    }
</script>








<script>
    var canvas = document.getElementById('canvas');
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    var gl = canvas.getContext('experimental-webgl');
    gl.getExtension('OES_texture_float');


    /*****************************************************************/
    /**************************BUILD SHADERS**************************/
    /*****************************************************************/
    var passPositionVertexShaderSource = document.getElementById('pass-position-vertex-shader').text;
    var passPositionVertexShader = buildVertexShader(gl, passPositionVertexShaderSource);
    
    var heightInitInFrequencyFragmentShaderSource = document.getElementById('height-init-in-frequency-fragment-shader').text;
    var heightInitInFrequencyFragmentShader = buildFragmentShader(gl, heightInitInFrequencyFragmentShaderSource);

    var heightAfterTInFrequencyFragmentShaderSource = document.getElementById('height-after-t-in-frequency-fragment-shader').text;
    var heightAfterTInFrequencyFragmentShader = buildFragmentShader(gl, heightAfterTInFrequencyFragmentShaderSource);

    var ifftRowsFragmentShaderSource = document.getElementById('ifft-rows-fragment-shader').text;
    var ifftRowsFragmentShader = buildFragmentShader(gl, ifftRowsFragmentShaderSource);
    
    var ifftColsFragmentShaderSource = document.getElementById('ifft-cols-fragment-shader').text;
    var ifftColsFragmentShader = buildFragmentShader(gl, ifftColsFragmentShaderSource);
    

    /*****************************************************************/
    /*************************INIT TEXTURES***************************/
    /*****************************************************************/
    var randomNormalPairs = [];
    for (var i = 0; i < HEIGHT * WIDTH; i++){
        randomNormalPairs.push(randomNormal());
        randomNormalPairs.push(randomNormal());
        randomNormalPairs.push(0);
        randomNormalPairs.push(0);
    }

    var randomNormalPairsTexture     = buildDataTexture(gl, UNIT_TEXTURE_RANDOM_NORMAL_PAIRS,      WIDTH, HEIGHT, new Float32Array(randomNormalPairs));
    var initHeightInFrequencyTexture = buildDataTexture(gl, UNIT_TEXTURE_INIT_HEIGHT_IN_FREQUENCY, WIDTH, HEIGHT, null);
    var pingTexture                  = buildDataTexture(gl, UNIT_TEXTURE_PING, WIDTH, HEIGHT, null);
    var pongTexture                  = buildDataTexture(gl, UNIT_TEXTURE_PONG, WIDTH, HEIGHT, null);



    /*****************************************************************/
    /***********************INIT FRAMEBUFFERS*************************/
    /*****************************************************************/
    var initHeightInFrequencyFramebuffer = buildFramebuffer(gl, initHeightInFrequencyTexture);
    var pingFramebuffer = buildFramebuffer(gl, pingTexture);
    var pongFramebuffer = buildFramebuffer(gl, pongTexture);


    var isPingCurrent = true;
    var changeCurrentPingPong = function() { isPingCurrent = !isPingCurrent; }
    var getCurrentPingPongTexture = function() { return isPingCurrent ? pingTexture : pongTexture; }
    var getCurrentPingPongFramebuffer = function() { return isPingCurrent ? pingFramebuffer : pongFramebuffer; }
    var getCurrentPingPongTextureUnit = function() { return isPingCurrent ? UNIT_TEXTURE_PING : UNIT_TEXTURE_PONG; }

    /*****************************************************************/
    /***********************BUILD PROGRAMS****************************/
    /*****************************************************************/
    var initHeightInFrequencyProgram = buildProgramData(gl, passPositionVertexShader, heightInitInFrequencyFragmentShader, 
        { 'a_position': A_POSITION_INDEX });
    gl.useProgram(initHeightInFrequencyProgram.program);
    gl.uniform1i(initHeightInFrequencyProgram.uniformLocations['u_randomComplexNumbers'], UNIT_TEXTURE_RANDOM_NORMAL_PAIRS);
    gl.uniform2f(initHeightInFrequencyProgram.uniformLocations['u_windVector'], WIND_X, WIND_Y);
    gl.uniform1f(initHeightInFrequencyProgram.uniformLocations['u_transformSize'], TRANSFORM_SIZE);
    gl.uniform1f(initHeightInFrequencyProgram.uniformLocations['u_areaSize'], AREA_SIZE);

    var heightAfterTInFrequencyProgram = buildProgramData(gl, passPositionVertexShader, heightAfterTInFrequencyFragmentShader, 
        { 'a_position': A_POSITION_INDEX });
    gl.useProgram(heightAfterTInFrequencyProgram.program);
    gl.uniform1i(heightAfterTInFrequencyProgram.uniformLocations['u_h0'], UNIT_TEXTURE_INIT_HEIGHT_IN_FREQUENCY);
    gl.uniform1f(heightAfterTInFrequencyProgram.uniformLocations['u_transformSize'], TRANSFORM_SIZE);
    gl.uniform1f(heightAfterTInFrequencyProgram.uniformLocations['u_areaSize'], AREA_SIZE);
    gl.uniform1f(heightAfterTInFrequencyProgram.uniformLocations['u_t'], 1.0);

    var ifftRowsProgram = buildProgramData(gl, passPositionVertexShader, ifftRowsFragmentShader, 
        { 'a_position': A_POSITION_INDEX });
    gl.useProgram(ifftRowsProgram.program);
    // gl.uniform1i(ifftRowsProgram.uniformLocations['u_input'], UNIT_TEXTURE_PING);
    gl.uniform1f(ifftRowsProgram.uniformLocations['u_transformSize'], TRANSFORM_SIZE);
    // gl.uniform1f(ifftRowsProgram.uniformLocations['u_subtransformSize'], TRANSFORM_SIZE);

    var ifftColsProgram = buildProgramData(gl, passPositionVertexShader, ifftColsFragmentShader, 
        { 'a_position': A_POSITION_INDEX });
    gl.useProgram(ifftColsProgram.program);
    // gl.uniform1i(ifftColsProgram.uniformLocations['u_input'], UNIT_TEXTURE_PING);
    gl.uniform1f(ifftColsProgram.uniformLocations['u_transformSize'], TRANSFORM_SIZE);
    // gl.uniform1f(ifftColsProgram.uniformLocations['u_subtransformSize'], TRANSFORM_SIZE);

    /*****************************************************************/
    /****************RENDER INIT HEIGHT IN FREQUENCY******************/
    /*****************************************************************/

    gl.enableVertexAttribArray(A_POSITION_INDEX);

    var fullscreenVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, fullscreenVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW); 
  


    gl.bindBuffer(gl.ARRAY_BUFFER, fullscreenVertexBuffer);
    gl.vertexAttribPointer(A_POSITION_INDEX, 2, gl.FLOAT, false, 0, 0);



    gl.useProgram(initHeightInFrequencyProgram.program);
    // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, initHeightInFrequencyFramebuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);








    var time = 0.0;

    var nextFrame = function(){
        time += 0.1;

        gl.useProgram(heightAfterTInFrequencyProgram.program);
        gl.uniform1f(heightAfterTInFrequencyProgram.uniformLocations['u_t'], time);
        gl.bindFramebuffer(gl.FRAMEBUFFER, getCurrentPingPongFramebuffer());
        // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.drawArrays(gl.TRIANGLES, 0, 6);


        var subtransformSize = 2;
        while(subtransformSize <= TRANSFORM_SIZE){
            gl.useProgram(ifftRowsProgram.program);
            gl.uniform1i(ifftRowsProgram.uniformLocations['u_input'], getCurrentPingPongTextureUnit());
            gl.uniform1f(ifftRowsProgram.uniformLocations['u_subtransformSize'], subtransformSize);

            changeCurrentPingPong();
            gl.bindFramebuffer(gl.FRAMEBUFFER, getCurrentPingPongFramebuffer());
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            subtransformSize *= 2;
        }

        subtransformSize = 2;
        while(subtransformSize <= TRANSFORM_SIZE){
            gl.useProgram(ifftColsProgram.program);
            gl.uniform1i(ifftColsProgram.uniformLocations['u_input'], getCurrentPingPongTextureUnit());
            gl.uniform1f(ifftColsProgram.uniformLocations['u_subtransformSize'], subtransformSize);

            changeCurrentPingPong();
            gl.bindFramebuffer(gl.FRAMEBUFFER, getCurrentPingPongFramebuffer());
            if(subtransformSize == 512){
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            subtransformSize *= 2;
        }

        // setTimeout(nextFrame, 100);
    }

    nextFrame();


</script>
